clc; clear; close all;
p1 = 7;    p2 = 21;    p3 = 5;  
levels = 3;
bands = 3*levels+1;
fname = 'db8'; 
mode = 's'; 
y = imread('lena512.jpg');
if(size(y,3)==3)
    y = rgb2gray(y);
end
[m, n] = size(y);
val = 0;
sigma = 20;
sizeB = size(y);
randn('seed', 212096);
yn = double(y) + (sigma * randn(sizeB)) + val;
yn = max(0, min(yn, 255));
yn_mse = sum(sum((double(y) - double(yn)).^2)) / (m * n);
yn_psnr = 10 * log10(255^2 / yn_mse);
if(isequal(fname, 'DCHWT'))
   dchw = dchwtf2(yn, 1);
   t1 = dchw{1}(:)';
else 
   [ca, ch, cv, cd] = dwt2(yn, fname);
   t1 = cd(:)';
end
median_val = median(abs(t1));
std_dev = (median_val / 0.6745);
tic
z1 = nlmeans_filt2D(yn, p3, p1, p2, std_dev);
toc
y_diff = double(yn) - z1;
dwtmode('per');
[C, S] = wavedec2(y_diff, levels, fname);
idx = bands;
CW{idx} = reshape(C(1:S(1,1)*S(1,2)), S(1,1), S(1,2));
idx = idx - 1;
start_idx = S(1,1) * S(1,2);
for i = 2:size(S, 1) - 1
   len = S(i,1) * S(i,2);
   CW{idx} = reshape(C(start_idx + len + 1 : start_idx + 2 * len), S(i,1), S(i,2));
   CW{idx - 1} = reshape(C(start_idx + 1 : start_idx + len), S(i,1), S(i,2));
   CW{idx - 2} = reshape(C(start_idx + 2 * len + 1 : start_idx + 3 * len), S(i,1), S(i,2));
   start_idx = start_idx + 3 * len;
   idx = idx - 3;
end
t2 = CW{1}(:)';
median_val2 = median(abs(t2));
std_dev2 = (median_val2 / 0.6745);
cw_noise = std_dev2^2;
for i = 1:bands - 1
    th = bayesthf(CW{i}, cw_noise);
    yw{i} = threshf(CW{i}, mode, th, 2);    
end
yw{i + 1} = CW{i + 1};
idx = bands;
xr_temp = reshape(yw{idx}, 1, S(1,1)*S(1,2));
idx = idx - 1;
for i = 2:size(S, 1) - 1
   xr_temp = [xr_temp reshape(yw{idx - 1}, 1, S(i,1)*S(i,2)) reshape(yw{idx}, 1, S(i,1)*S(i,2)) reshape(yw{idx - 2}, 1, S(i,1)*S(i,2))];
   idx = idx - 3;
end
y_denoised = waverec2(xr_temp, S, fname);
final_denoised = z1 + y_denoised;
final_denoised_uint8 = uint8(final_denoised);
toc
yn_mse2 = sum(sum((double(y) - double(z1)).^2)) / (m * n);
yn_denoised_mse = sum(sum((double(y) - double(final_denoised_uint8)).^2)) / (m * n);
fname, sigma, yn_psnr
psnr_nl = 10 * log10(255^2 / yn_mse2);
psnr_denoised = 10 * log10(255^2 / yn_denoised_mse);
psnr_denoised - psnr_nl;
mean_org = mean(y(:));
var_org = sum((y(:) - mean_org).^2) / (m * n - 1);
final_nl = uint8(z1);
mean_nl = mean(final_nl(:));
var_nl = sum((final_nl(:) - mean_nl).^2) / (m * n - 1);
cross_var_wt = sum((y(:) - mean_org) .* (final_nl(:) - mean_nl)) / (m * n - 1);
IQI_nl = (4 * cross_var_wt * mean_org * mean_nl) / ((var_org + var_nl) * (mean_org^2 + mean_nl^2));
mean_nl_denoised = mean(final_denoised_uint8(:));
var_nl_denoised = sum((final_denoised_uint8(:) - mean_nl_denoised).^2) / (m * n - 1);
cross_var_wt_denoised = sum((y(:) - mean_org) .* (final_denoised_uint8(:) - mean_nl_denoised)) / (m * n - 1);
IQI_nl_denoised = (4 * cross_var_wt_denoised * mean_org * mean_nl_denoised) / ((var_org + var_nl_denoised) * (mean_org^2 + mean_nl_denoised^2));
vif_nl = vifvec(double(y), z1);
vif_nl_denoised = vifvec(double(y), final_denoised);
vif_nl, psnr_nl, IQI_nl
vif_nl_denoised, psnr_denoised, IQI_nl_denoised
figure, imshow(uint8(z1)), colormap gray, title('NL');
figure, imshow(final_denoised_uint8), colormap gray, title('NL');
mn = yn - double(y);
mn_nl = y_denoised;
mn_nl_denoised = yn - double(final_denoised_uint8);


function im_rec=nlmeans_filt2D(xn,sigmas,ksize,ssize,noise_std)
half_ksize=floor(ksize/2);
half_ssize=floor(ssize/2);
[M,N]=size(xn);
xm=zeros(M+ssize-1,N+ssize-1);
xm(half_ssize+1:M+half_ssize,half_ssize+1:N+half_ssize)=xn;
xm(1:half_ssize,:)=xm(ssize:-1:half_ssize+2,:);
xm(M+half_ssize+1:M+ssize-1,:)=xm(M+half_ssize-1:-1:M,:);
xm(:,1:half_ssize)=xm(:,ssize:-1:half_ssize+2);
xm(:,N+half_ssize+1:N+ssize-1)=xm(:,N+half_ssize-1:-1:N);
gauss_win=gauss_ker2D(sigmas,ksize);
filt_h=0.55*noise_std;
[M,N]=size(xm);
for ii=half_ssize+1:M-half_ssize
   for jj=half_ssize+1:N-half_ssize
      xtemp=xm(ii-half_ksize:ii+half_ksize,jj-half_ksize:jj+half_ksize);      
      search_win=xm(ii-half_ssize:ii+half_ssize,jj-half_ssize:jj+half_ssize);
      for kr=1:(ssize-ksize+1)
         for kc=1:(ssize-ksize+1)   
            euclid_dist=(xtemp-search_win(kr:kr+ksize-1,kc:kc+ksize-1)).^2;
            wt_dist=gauss_win.*euclid_dist;
            sq_dist=sum(sum((wt_dist)))/(ksize^2);
            weight(kr,kc)=exp(-max(sq_dist-(2*noise_std^2),0)/filt_h^2);
         end
      end
      sum_wt=sum(sum(weight));
      weightn=weight/sum_wt;
      sum_pix=sum(sum(search_win(half_ksize+1:ssize-half_ksize,half_ksize+1:ssize-half_ksize).*weightn));
      im_rec(ii-half_ssize,jj-half_ssize)=sum_pix;
   end
end

clear;
clc;

addpath(genpath('source-code/'));

img = imread('02_ori.png');

figure;
imshow([double(img)/255,NUM(img)]);

function [oimgf] = NUM(img,sv,sigma,iterNum,ceEn,gammaMin,gammaMax,n)

switch nargin
    case 1
        sv = 5;
        sigma = 1e-4;
        iterNum = 20;
        ceEn = false;
        gammaMin = 1;
        gammaMax = 5;
        n = 0.5;
    case 2
        sigma = 1e-4;
        iterNum = 20;
        ceEn = false;
        gammaMin = 1;
        gammaMax = 5;
        n = 0.5;
    case 3
        iterNum = 20;
        ceEn = false;
        gammaMin = 1;
        gammaMax = 5;
        n = 0.5;
    case 4
        ceEn = false;
        gammaMin = 1;
        gammaMax = 5;
        n = 0.5;
    case 5
        gammaMin = 1;
        gammaMax = 5;
        n = 0.5;
    case 6
        gammaMax = 5;
        n = 0.5;
    case 7
        n = 0.5;
    otherwise
end

img(img==0) = 1;
img(img==255) = 254;
imgf = double(img)/255;

hsv = rgb2hsv(imgf);
x = hsv(:,:,3);
x = 2*x-1;

yk = x;
H = [];
while iterNum>0
    iterNum = iterNum-1;
    yk1 = hmfm_v33(yk,sv);
    Hnew = mean2(abs(yk1.^2-yk.^2));
    H = cat(1,H,Hnew);
    if Hnew<sigma
        disp('Terminate while loop.');
        disp(iterNum);
        break;
    else
        yk = yk1;
    end
end
y = yk1;

% detail signal
d = funcRev(func(x)+func(-y));

if ceEn
    y = adapthisteq(y,'ClipLimit',0.02);
else
end

beta = (gammaMax-gammaMin)/(1-exp(-1));
alpha = gammaMax-beta;
adaptGamma = alpha+beta*exp(-abs(d).^n);
adaptDw = funcRev(adaptGamma.*func(d));
z2 = funcRev(func(y)+func(adaptDw));
z2 = (1+z2)/2;

oimgf = hsv2rgb(cat(3,hsv(:,:,1),hsv(:,:,2),z2));

end

function y = func(x)
    y = log((1+x)./(1-x+eps));
end

function x = funcRev(y)
    x = (exp(y)-1)./(exp(y)+1);
end

function hm = hmfm_v33(input,sv)

switch nargin
    case 2
    case 1
        sv = 3; % default 3x3
    otherwise
        warning('Please check input arguments!');
        return;
end

input_pad = sympad(input,sv);

square = true(sv,sv);

cross = false(sv,sv);
cross((sv+1)/2,:) = true;
cross(:,(sv+1)/2) = true;

diag = false(sv,sv);
diag((1:sv)+sv*(0:sv-1)) = true;
diag((1:sv)+sv*((sv-1):-1:0)) = true;

hmtemp = hybridMedfilt(input_pad);

hm = hmtemp((sv+1)/2:end-(sv-1)/2,(sv+1)/2:end-(sv-1)/2);

    % Hybrid median filter
    function hm = hybridMedfilt(inImg)
        
        % Filtering
        hm1 = ordfilt2(inImg,(sv*sv+1)/2,square);
        hm2 = ordfilt2(inImg,sv,cross);
        hm3 = ordfilt2(inImg,sv,diag);
        hm4 = cat(3,hm1,hm2,hm3);
        hm4 = sort(hm4,3);
        hm = hm4(:,:,2);

    end
end

function inpad = sympad(in,sv)

[y,x] = size(in);
ypad = y+(sv-1);
xpad = x+(sv-1);
inpad = zeros(ypad,xpad);
inpad((sv+1)/2:end-(sv-1)/2,(sv+1)/2:end-(sv-1)/2) = in;

upmask = false(ypad,xpad);
upmask((sv+1)/2+1:sv,:) = true;
uppad = reshape(inpad(upmask),[(sv-1)/2,xpad]);
uppad = uppad(end:-1:1,:);

lowmask = false(ypad,xpad);
lowmask(end-(sv-1):end-(sv-1)/2-1,:) = true;
lowpad = reshape(inpad(lowmask),[(sv-1)/2,xpad]);
lowpad = lowpad(end:-1:1,:);

inpad(1:(sv+1)/2-1,:) = uppad;
inpad(end-(sv-1)/2+1:end,:) = lowpad;

leftmask = false(ypad,xpad);
leftmask(:,(sv+1)/2+1:sv) = true;
leftpad = reshape(inpad(leftmask),[ypad,(sv-1)/2]);
leftpad = leftpad(:,end:-1:1);

rightmask = false(ypad,xpad);
rightmask(:,end-(sv-1):end-(sv-1)/2-1) = true;
rightpad = reshape(inpad(rightmask),[ypad,(sv-1)/2]);
rightpad = rightpad(:,end:-1:1);

inpad(:,1:(sv+1)/2-1) = leftpad;
inpad(:,end-(sv-1)/2+1:end) = rightpad;

end

clear;
rng('default');
workDir = pwd;
noisestep = -0.1;
features_file = 'Predicted_features.mat';
Subjects = {'Subject1', 'Subject2', 'Subject3', 'Subject4', 'Subject5'};
DNNlayers = {'DNN1', 'DNN2', 'DNN3', 'DNN4', 'DNN5', 'DNN6', 'DNN7', 'DNN8'};
modtxt = {'0%','6%', '12%','25%'};
feat_per_layer = 1000;
SNR = 10:noisestep:-100;
saveFileName = 'Feature_Correlation.mat';
fprintf('Loading decoded features...\n');
load(fullfile(workDir,'results',features_file),'pred_feat','true_feat',...
    'Test', 'Subjects','DNNlayers','RoiNames');
m = Test(1).modification;
tfeat = true_feat;
ofeat = tfeat(:,:,m == 1);
ofeat = repelem(ofeat, 1,1,length(modtxt));
noised_matsize = [length(SNR), size(ofeat)];
ofeat_noise = zeros(noised_matsize);
corrnoiseo = zeros(length(SNR),8,size(ofeat,3)); 
corrnoises = zeros(length(SNR),8,size(ofeat,3));
ofeatcorrmean = zeros(length(SNR),length(DNNlayers), length(modtxt));
fprintf('Calculating correlation of decoded features...\n');
for subject = 1:length(Subjects)
    for roi = 1:length(RoiNames)
        pfeat = pred_feat{subject,roi}; 
        for layer = 1:length(DNNlayers)
            for img = 1:size(ofeat,3) 
                tempp = squeeze(pfeat(layer,:,img));
                tempt = squeeze(tfeat(layer,:,img));
                tempo = squeeze(ofeat(layer,:,img));
                corrpreds(subject,roi,layer,img) = corr(tempp', tempt'); %r_s
                corrpredo(subject,roi,layer,img) = corr(tempp', tempo'); %r_o
            end
        end
    end
end
fprintf('Creating noisy features...\n');
for s = 1:length(SNR)
    for layer = 1:length(DNNlayers)
        for img = 1:size(ofeat,3)
            temp = squeeze(tfeat(layer,:,img));
            temp1 = awgn(temp,SNR(s),'measured');
            tempo = squeeze(ofeat(layer,:,img));
            %corrlation calculation
            corrnoiseo(s,layer,img) = corr(temp1',tempo');
            corrnoises(s,layer,img) = corr(temp1',temp');
        end
    end
end
for s = 1:(length(SNR))
    for layer = 1:length(DNNlayers)
        for mod = 1:length(modtxt)
            ofeatcorrmean(s,layer,mod) = mean(squeeze(corrnoiseo(s,layer,(m == mod))));
            for roi = 1:length(RoiNames)        
                for subject = 1:length(Subjects)
                    origmean_sub(subject,roi,layer,mod) = ...
                        mean(squeeze(corrpredo(subject,roi,layer,(m == mod))));
                end
            
            end
           
        end
    end
end
fprintf('Noise matching...\n');
ind = [];
for roi = 1:length(RoiNames)
    ofeat_orig = squeeze(ofeatcorrmean(:,:,1));
    pred_orig_mean = squeeze(origmean_sub(:,:,:,1));
    
    for layer = 1:length(DNNlayers)
        for subject = 1:length(Subjects)
            Diff = abs(ofeat_orig(:,layer) - pred_orig_mean(subject,roi,layer));
            equal_pt = find(Diff == min(Diff));
            if pred_orig_mean(subject,roi,layer) >= 0
                ind(subject,roi,layer) = equal_pt(1);
            else
                Diff = ofeat_orig(:,layer);
                equal_pt = find(Diff < 0);
                ind(subject,roi,layer) = equal_pt(1);
            end
        end
    end
end
fprintf('Saving results...\n');
save(fullfile(workDir,'results',saveFileName), 'ind', 'Test', ...
    'corrnoiseo','corrnoises','corrpreds', 'corrpredo', ...
    'Subjects','DNNlayers','RoiNames', '-v7.3');
fprintf('Done!\n');
TrainFeatureDecoders;
pause(1);
PredictFeatures;
pause(1);
EstimateMatchedNoise;
pause(1);
PlotFeatureGain;

clear;
workDir = pwd;
results_file = 'Feature_Correlation.mat';
Subjects = {'Subject1', 'Subject2', 'Subject3', 'Subject4', 'Subject5'};
DNNlayers = {'DNN1', 'DNN2', 'DNN3', 'DNN4', 'DNN5', 'DNN6', 'DNN7', 'DNN8'};
modtxt = {'0%','6%', '12%','25%'}; %different blur levels
alpha = 0.05; 
rep_subject = 4;
rep_layer   = 6;
fprintf('Loading noise matched features... \n');
load(fullfile(workDir,'results',results_file), 'ind', 'Test', ...
    'corrnoiseo','corrnoises','corrpreds', 'corrpredo',...
    'Subjects','DNNlayers','RoiNames');
roi = 8; 
fprintf('ROI is %s\n', RoiNames{roi});
for subject = 1:length(Subjects)
    for layer = 1:length(DNNlayers)
        matched_corrnoiseo(subject,layer,:) = corrnoiseo(ind(subject,roi,layer),layer,:);
        matched_corrnoises(subject,layer,:) = corrnoises(ind(subject,roi,layer),layer,:);
    end
end
for subject = 1:length(Subjects)
    corrpredo_roi(subject, :,:) = squeeze(corrpredo(subject,roi,:,:));
    corrpreds_roi(subject, :,:) = squeeze(corrpreds(subject,roi,:,:));
end
m = Test(1).modification;
for mod = 1:length(modtxt)
    corrpredo_roi_mod(:,:,:,mod) = corrpredo_roi(:,:,(m == mod));
    corrpreds_roi_mod(:,:,:,mod) = corrpreds_roi(:,:,(m == mod));
end
corrpredd_roi_mod = corrpredo_roi_mod - corrpreds_roi_mod;

fprintf('Calculating feature gain...\n')
for subject = 1:length(Subjects)
    ofeat_gain(subject, :,:) = squeeze(corrpredo(subject,roi,:,:))...
        - squeeze(matched_corrnoiseo(subject,:,:));
    tfeat_gain(subject, :,:) = squeeze(corrpreds(subject,roi,:,:))...
        - squeeze(matched_corrnoises(subject,:,:));
end
for mod = 1:length(modtxt)
    ofeat_gain_m(:,:,:,mod) = ofeat_gain(:,:,(m == mod));
    tfeat_gain_m(:,:,:,mod) = tfeat_gain(:,:,(m == mod));
end
feature_gain = ofeat_gain_m - tfeat_gain_m;

fprintf('Displaying plots for %s from %s\n',Subjects{rep_subject},DNNlayers{rep_layer});
Xdata = squeeze(corrpredo_roi(rep_subject, rep_layer,:));
Ydata = squeeze(corrpreds_roi(rep_subject, rep_layer,:));

Xdatamean = squeeze(mean(corrpredo_roi_mod(rep_subject,rep_layer,:,:),3));
Ydatamean = squeeze(mean(corrpreds_roi_mod(rep_subject,rep_layer,:,:),3));

for mod = 1:length(modtxt)
    noise_o(mod) = squeeze(mean(matched_corrnoiseo(rep_subject,rep_layer,m == mod),3));
    noise_s(mod) = squeeze(mean(matched_corrnoises(rep_subject,rep_layer,m == mod),3));
end

feature_gain_modmean = squeeze(mean(feature_gain,3));
feature_gain_submean = squeeze(mean(feature_gain_modmean,1));
SEM = std(feature_gain_modmean,0,1)/sqrt(size(feature_gain_modmean,1)); % Standard Error
ts = tinv([alpha/2  1-alpha/2],size(feature_gain_modmean,1)-1); % T-Score
feature_gain_subci  = ts(2)*squeeze(SEM);

HH = figure('units','centimeters','outerposition',[1 0 21 29.7],'Color',[1,1,1]);

subplot (8,2,1:2:6); hold on;
set(gca, 'fontsize', 10,'fontname', 'Arial');
colors = {[1,1,1]*0.1,[1,1,1]*0.4,[1,1,1]*0.7};
markershapes = {'o', '^', 's'};
for mod = 2:length(modtxt) % skip original
    scatter(Xdata((m == mod)),Ydata((m == mod)),...
        30,'filled',markershapes{mod-1},'MarkerFaceColor',colors{mod-1},...
        'MarkerFaceAlpha',0.7);
end

legend(modtxt(2:length(modtxt)),'Location','NorthWest');

for mod = 2:length(modtxt)  % skip original

    scatter(Xdatamean(mod),Ydatamean(mod), 50, 'Marker',markershapes{mod-1}, ...
        'LineWidth', 2,'MarkerEdgeColor', 'k','MarkerFaceColor','w','MarkerFaceAlpha',0.7);

end

set(gca, 'XTick' , -0.5:0.5:0.5,'YTick' , -0.5:0.5:0.5);
axis equal;
xlim([-0.3,0.7]); ylim([-0.3,0.7]); 
line([-1,0.6],[-1,0.6],'LineWidth',1, 'Color','k');

subplot (8,2,7:2:10); hold on;
set(gca, 'fontsize', 10,'fontname', 'Arial');
plot(Xdatamean,'Color',[0,0,0], 'LineWidth', 1);
plot(Ydatamean,'Color',[0.7,0.7,0.7], 'LineWidth', 1);
ylim([0,0.3]);
ylabel ('Correlation:\newlinedecoded features');
set(gca, 'XTick' , 1:length(modtxt), 'XTickLabel', modtxt);
xlabel('Blur level')
xlim([0.5, 4.5]);
set(gca,'XColor', [0,0,0],'YColor', [0,0,0]);
legend({'r_o', 'r_s'},'Location','NorthEast');

subplot (8,2,13:2:16); hold on;
set(gca, 'fontsize', 10,'fontname', 'Arial');
plot(noise_o,'Color',[0,0,0], 'LineWidth', 1);
plot(noise_s,'Color',[0.7,0.7,0.7], 'LineWidth', 1);
ylim([0,0.3]);
ylabel ('Correlation:\newlinenoise-matched features');
set(gca, 'XTick' , 1:length(modtxt), 'XTickLabel', modtxt);
xlabel('Blur level')
xlim([0.5, 4.5]);
set(gca,'XColor', [0,0,0],'YColor', [0,0,0]);

for layer = 1:length(DNNlayers)
    subplot (8,2,18-2*layer); hold on;
    set(gca, 'fontsize', 10,'fontname', 'Arial');
    bar(feature_gain_submean(layer,2:length(modtxt)),'EdgeColor', 'none');
    errorbar(feature_gain_submean(layer,2:length(modtxt)),...
        feature_gain_subci(layer,2:length(modtxt)),'.k');
    ylim([-0.1,0.3]);
    if layer == 4
        ylabel('Feature gain (\Deltar_{decode} - \Deltar_{noise})');
    end
    if layer == 1
        set(gca, 'XTick' , 1:3, 'XTickLabel', modtxt(2:end));
    end
    colormap('gray');
    set(gca,'XColor', [0,0,0],'YColor', [0,0,0]);
end

clear;
rng('default');
Subjects = {'Subject1', 'Subject2', 'Subject3', 'Subject4', 'Subject5'};
DNNlayers = {'DNN1', 'DNN2', 'DNN3', 'DNN4', 'DNN5', 'DNN6', 'DNN7', 'DNN8'};
feat_per_layer = 1000;
addpath(genpath(fullfile(pwd,'lib')));
workDir = pwd;
dataFolder = fullfile(workDir,'data');

fprintf('Loading Image Features\n');
ImageFeatures = load(fullfile(dataFolder,'ImageFeatures.mat'), 'dataSet', 'metaData');
trtest = get_dataset(ImageFeatures.dataSet, ImageFeatures.metaData, 'TrTest');
imgcode_feat = get_dataset(ImageFeatures.dataSet, ImageFeatures.metaData, 'ImageCode');

imgcode_feat = imgcode_feat(trtest == 2);

for layer = 1:length(DNNlayers)
    selectCond = ['DNN_layer = ', num2str(layer)];
    image_features = select_feature(ImageFeatures.dataSet, ImageFeatures.metaData, selectCond);
    image_features = image_features(trtest == 2, :);
    for feat = 1:feat_per_layer
        labels{layer, feat} = image_features(:,feat);
    end
    
end

for subject = 1:length(Subjects)
    fprintf('Loading fMRI data from %s\n', Subjects{subject});
    load(fullfile(dataFolder,Subjects{subject}), 'dataSet', 'metaData', 'RoiNames', 'SubjectName');
    
    Test(subject).subjectname = SubjectName;
    
    imgcode = get_dataset(dataSet, metaData, 'ImageCode');
    modification = get_dataset(dataSet, metaData, 'Modification');
    condition = get_dataset(dataSet, metaData, 'Condition');
    correct = get_dataset(dataSet, metaData, 'Correct');
    certain = get_dataset(dataSet, metaData, 'Certain');
    category = get_dataset(dataSet, metaData, 'Category');
    trtest = get_dataset(dataSet, metaData, 'TrTest');
        
    Test(subject).imgcode = imgcode(trtest == 2);
    Test(subject).condition = condition(trtest == 2);
    Test(subject).modification = modification(trtest == 2);
    Test(subject).category = category(trtest == 2);
    Test(subject).correct = correct(trtest == 2);
    Test(subject).certain = certain(trtest == 2);
    
    for roi = 1:length(RoiNames)
        selectCond = [RoiNames{roi} , '= 1'];
        x = select_feature(dataSet, metaData, selectCond);
        Test(subject).x{roi} = x(trtest == 2,:);
    end
    
    imgcode_cat = Test(subject).category(logical(Test(subject).condition))*100 + ...
        Test(subject).imgcode(logical(Test(subject).condition));
    imgcode = [Test(subject).imgcode(~Test(subject).condition) ; ...
        imgcode_cat];
    
    [~, ind] = sort(imgcode, 'ascend'); %feature imgcode is already sorted 
    Test(subject).imgcode = Test(subject).imgcode(ind);
    Test(subject).condition = Test(subject).condition(ind);
    Test(subject).modification = Test(subject).modification(ind);
    Test(subject).category = Test(subject).category(ind);
    Test(subject).correct = Test(subject).correct(ind);
    Test(subject).certain = Test(subject).certain(ind);
    
    for roi = 1:length(RoiNames)
        Test(subject).x{roi} = Test(subject).x{roi}(ind,:);
    end
end

param.numFeatures   = 500;
param.Ntrain        = 20; 
param.Nskip         = 20;   
param.layercount    = 8;
param.featurecount  = 1000;

subroicomb = combvec(1:length(Subjects),1:length(RoiNames));
subroicomb = subroicomb';
for combsr = 1:size(subroicomb,1)
    
    modelnames{combsr} = ...
        strcat(Subjects{subroicomb(combsr,1)}, '_', RoiNames{subroicomb(combsr,2)}, '.mat');

    
end

setupdir(fullfile(workDir,'results'));
for combsr = 1:size(subroicomb,1)
    analysisName = modelnames{combsr};
    fprintf('Feature decoding from %s started...\n', analysisName(1:end-4));
    testvox = Test(subroicomb(combsr,1)).x{subroicomb(combsr,2)};
    load(fullfile(workDir,'models', analysisName));
    [predictedf, truef] = test_eachROI(model, testvox, labels, sigma4label, mu4label, sigma4feat, mu4feat, I4feat, param);

    pred_feat{subroicomb(combsr,1),subroicomb(combsr,2)} = predictedf;
    
    fprintf('[Done] Feature decodeing from %s...\n', analysisName(1:end-4));
        
end
true_feat =   truef;
DateCreated = date;
fprintf('Feature decodeing done!\n');
fprintf('Saving...\n');
save(fullfile(workDir,'results','Predicted_features.mat'),'pred_feat','true_feat',...
    'Test', 'Subjects','DNNlayers','RoiNames','DateCreated', '-v7.3');
fprintf('Done!\n');

clear;
rng('default');
Subjects = {'Subject1', 'Subject2', 'Subject3', 'Subject4', 'Subject5'};
DNNlayers = {'DNN1', 'DNN2', 'DNN3', 'DNN4', 'DNN5', 'DNN6', 'DNN7', 'DNN8'};
feat_per_layer = 1000;
addpath(genpath(fullfile(pwd,'lib')));
workDir = pwd;
lockDir = fullfile(workDir,'tmp');

dataFolder = fullfile(workDir,'data');

fprintf('Loading Image Features\n');
ImageFeatures = load(fullfile(dataFolder,'ImageFeatures.mat'), 'dataSet', 'metaData');
trtest = get_dataset(ImageFeatures.dataSet, ImageFeatures.metaData, 'TrTest');
imgcode_feat = get_dataset(ImageFeatures.dataSet, ImageFeatures.metaData, 'ImageCode');

imgcode_feat = imgcode_feat(trtest == 1);

for layer = 1:length(DNNlayers)
    selectCond = ['DNN_layer = ', num2str(layer)];
    image_features = select_feature(ImageFeatures.dataSet, ImageFeatures.metaData, selectCond);
    image_features = image_features(trtest == 1, :);
    for feat = 1:feat_per_layer
        labels{layer, feat} = image_features(:,feat);
    end
    
end

for subject = 1:length(Subjects)
    % load fRMI data file
    fprintf('Loading fMRI data from %s\n', Subjects{subject});
    load(fullfile(dataFolder,Subjects{subject}), 'dataSet', 'metaData', 'RoiNames', 'SubjectName');
    Train(subject).subjectname = SubjectName;
    Test(subject).subjectname = SubjectName;
    
    imgcode = get_dataset(dataSet, metaData, 'ImageCode');
    modification = get_dataset(dataSet, metaData, 'Modification');
    condition = get_dataset(dataSet, metaData, 'Condition');
    correct = get_dataset(dataSet, metaData, 'Correct');
    certain = get_dataset(dataSet, metaData, 'Certain');
    category = get_dataset(dataSet, metaData, 'Category');
    trtest = get_dataset(dataSet, metaData, 'TrTest');
    
    Train(subject).imgcode = imgcode(trtest == 1);
    
    Test(subject).imgcode = imgcode(trtest == 2);
    Test(subject).condition = condition(trtest == 2);
    Test(subject).modification = modification(trtest == 2);
    Test(subject).category = category(trtest == 2);
    Test(subject).correct = correct(trtest == 2);
    Test(subject).certain = certain(trtest == 2);
    
    for roi = 1:length(RoiNames)
        selectCond = [RoiNames{roi} , '= 1'];
        x = select_feature(dataSet, metaData, selectCond);
        Train(subject).x{roi} = x(trtest == 1,:);
        Test(subject).x{roi} = x(trtest == 2,:);
    end
    
    [~, ind] = sort(Train(subject).imgcode, 'ascend'); %feature imgcode is already sorted from 1 to 1000
    Train(subject).imgcode = Train(subject).imgcode(ind);
    for roi = 1:length(RoiNames)
        Train(subject).x{roi} = Train(subject).x{roi}(ind,:);
    end
end

param.numFeatures   = 500; %number of voxels for each ROI
param.Ntrain        = 200; % # of total training iteration (note that the number of iterations in the manuscript was 2000)
param.Nskip         = 200;     % skip steps for display info
param.layercount    = 8;    %number of layers
param.featurecount  = 1000; %number of features per layer

subroicomb = combvec(1:length(Subjects),1:length(RoiNames));
subroicomb = subroicomb';
for combsr = 1:size(subroicomb,1)
    
    modelnames{combsr} = ...
        strcat(Subjects{subroicomb(combsr,1)}, '_', RoiNames{subroicomb(combsr,2)}, '.mat');

    
end

model_exist = false(length(Subjects)*length(RoiNames),1);
if exist(fullfile(workDir,'models'))
    model_files = dir(fullfile(workDir,'models','*.mat'));
    for fi = 1:length(model_files)
        model_exist = model_exist | strcmp(model_files(fi).name,modelnames)';
        fprintf('Decoder %s model already exists... Skipped\n', model_files(fi).name(1:end-4));
    end
else
    mkdir(fullfile(workDir,'models'));
end

subroicomb(model_exist,:) = [];
modelnames(model_exist) = [];

for combsr = 1:size(subroicomb,1)
    analysisName = modelnames{combsr};
    % if model exists skip
    if exist(fullfile(workDir,'models',analysisName))
        fprintf('Decoder %s model already exists... Skipped\n', analysisName(1:end-4));
        continue;
    end
    
    if islocked(analysisName, lockDir)
        fprintf('Decoder %s training is already running... Skipped\n', analysisName(1:end-4));
        continue;
    end
    lockcomput(analysisName, lockDir);
    fprintf('Decoder %s training started\n', analysisName(1:end-4));
    trainingvox = Train(subroicomb(combsr,1)).x{subroicomb(combsr,2)};
    [model, sigma4label, mu4label, sigma4feat, mu4feat, I4feat] = train_eachROI(labels,trainingvox,param);
    
    save(fullfile(workDir,'models',modelnames{combsr}),'model','sigma4label','mu4label','sigma4feat','mu4feat','I4feat', '-v7.3');
    fprintf('Decoder %s training finished\n', analysisName(1:end-4));
    unlockcomput(analysisName, lockDir);
end
